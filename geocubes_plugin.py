# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeocubesPlugin
                                 A QGIS plugin
 Interface to download raster data from GeoCubes Finland
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-06-04
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Paikkatietokeskus FGI
        email                : lassi.lehto@nls.fi
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, Qt
from PyQt5.QtGui import QIcon, QFont
from PyQt5.QtWidgets import (QAction, QTableWidgetItem, QAbstractScrollArea,
                             QSizePolicy, QMainWindow, QDialog)
from qgis.core import (QgsProject, QgsCoordinateReferenceSystem, QgsRasterLayer,
                       QgsMessageLog, Qgis, QgsVectorLayer, QgsPalLayerSettings,
                       QgsVectorLayerSimpleLabeling, QgsTextFormat, 
                       QgsTextBufferSettings)
from qgis.gui import (QgsBusyIndicatorDialog, QgsMessageBar, QgsMapCanvas, 
                      QgsMapToolPan, QgsMapToolZoom)

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .geocubes_plugin_dialog import GeocubesPluginDialog
import os.path, requests, time


class GeocubesPlugin:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GeocubesPlugin_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&GeoCubes Plugin')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GeocubesPlugin', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/geocubes_plugin/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Download harmonised raster data'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&GeoCubes Plugin'),
                action)
            self.iface.removeToolBarIcon(action)

    def setResolution(self):
        """Resolution is set to be the one currently in the box"""
        self.resolution = self.resolution_box.currentText()
        
    def setAdminArea(self):
        self.admin_area = self.admin_areas_box.currentText()
        
    def sendWarning(self, title, text, duration):
        """Creates a warning on the top of the widget"""
        self.msg_bar.pushMessage(title, text, Qgis.Warning, 
                             duration = duration)
        
    def extentResolution(self):
        """Automatically suggests a resolution for the current map scale.
        Activated when user moves the canvas and updates the resolution box.
        Suggested resolution is reached via this formula:
        https://www.esri.com/arcgis-blog/products/product/imagery/on-map-scale-and-raster-resolution/?rmedium
        """
        
        # map scale as a double, i.e. 1:563000 -> 563000.000
        map_scale = self.canvas.scale()
        
        detectable_size = map_scale / 1000

        real_resolution = detectable_size / 2
        
        # fetch all resolutions from the box as integers
        all_resolutions = [int(self.resolution_box.itemText(i)) for i in range(self.resolution_box.count())]
        
        # find the resolution closest to the ones available. See:
        # https://stackoverflow.com/questions/12141150/from-list-of-integers-get-number-closest-to-a-given-value
        closest_resolution = min(all_resolutions, key=lambda x:abs(x-real_resolution))
        
        resolution_idx = self.resolution_box.findText(str(closest_resolution))
        
        self.resolution_box.setCurrentIndex(resolution_idx)
        
        self.setResolution()
        
        self.updateCountText()
        
            
    def getDatasets(self):
        """Sends a query to Geocubes and receives text describing the data.
           Returns a list of strings containing the datasets"""
        
        # request info from the server: if no response in 10 seconds, timeout
        response = requests.get(self.url_base + "/info/getDatasets", timeout=10)
        
        # request status code indicates whether succesful: if not, return false
        # and warn user
        s_code = response.status_code
        
        if (s_code == 204):
            self.sendWarning("Empty response", "Failed to fetch datasets. Error: "+
                             str(s_code), 10)
            return False
        
        if (s_code >= 500):
            self.sendWarning("Server error", "Failed to fetch datasets. Error: "+
                             str(s_code), 10)
            return False
        
        if (s_code >= 400):
            self.sendWarning("Client error", "Failed to fetch datasets. Code: "+
                             str(s_code), 10)
            return False

        # decode from bytes to string
        response_string = response.content.decode("utf-8")

        # datasets are divided by semicolons: split at semicolons
        dataset_list = response_string.split(';')

        return dataset_list

    def setToTable(self):
        """
        Activated when user clicks "Fetch datasets" button. This function
        lists available data to the user and creates checkboxes that allow
        the selection of said data. Also creates signals that cannot be
        created on first start, like the signal emitted when clicking 
        on a checkbox.
        """
        # if previous signals exist, i.e. the plugin is started multiple times,
        # remove the connections. If none exist, pass
        try: self.table.itemChanged.disconnect() 
        except Exception: pass

        # get a list of datasets
        datasets = self.getDatasets()
        
        # if capabilities query failed, don't run code below
        if not datasets:
            return

        self.table.setColumnCount(4)
        # start with only 1 row, add more as needed
        self.table.setRowCount(1)
        # set headers for all 4 columns
        self.table.setHorizontalHeaderLabels(['Label', 'Year', 'Max resolution (m)', 'Select layer'])

        # loop through all the datasets
        for i, dataset in enumerate(datasets):
            # entries in the datasets are separated by commas
            dataset_split = dataset.split(',')

            # each entry has seven pieces of info, but only four are needed

            # label = a plain language name for the dataset: can have spaces etc.
            label = dataset_split[0]

            # name = version of label used in queries etc.
            name = dataset_split[1]
            years = dataset_split[2]
            # maxres = maximum resolution of the dataset in meters
            maxres = dataset_split[5]

            # years are separated by periods
            years_split = years.split('.')
            
            # one dataset may have data from multiple years
            # this is handled by adding each year on its own row
            for year in years_split:
                # the strings must be transformed to Qt Items
                label_entry = QTableWidgetItem(label)
                # the items must NOT be selectable or otherwise modifiable
                label_entry.setFlags(Qt.NoItemFlags)
                maxres_entry = QTableWidgetItem(maxres)
                maxres_entry.setFlags(Qt.NoItemFlags)
                year_entry = QTableWidgetItem(year)
                year_entry.setFlags(Qt.NoItemFlags)
                
                # create a checkbox for each row
                checkbox_entry = QTableWidgetItem()
                checkbox_entry.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
                # start with checkbox unchecked
                checkbox_entry.setCheckState(Qt.Unchecked)
                
                # get the current row count from the table
                row_count = self.table.rowCount()
                
                """Next, add info of the dataset to our dictionary. The dict
                will later be accessed via the list of downloadable datasets:
                it will house the keys. This way may seem redundant, but it's done
                since the name variable isn't needed on the table but is later
                necessary for the queries. Key is stored as a string and 
                value as a tuple"""
                key = label + ";" + year
                value = (name, year)
                
                self.datasets_all[key] = value
                
                # add the previously created items on the table
                self.table.setItem(row_count-1, 0, label_entry)
                self.table.setItem(row_count-1, 1, year_entry)
                self.table.setItem(row_count-1, 2, maxres_entry)
                self.table.setItem(row_count-1, 3, checkbox_entry)
                
                # if there're datasets left, add a new row
                if i < len(datasets)-1:
                    self.table.setRowCount(row_count+1)
        
        # fit column sizes to the items
        self.table.resizeColumnsToContents()
        
        # when an item's content are changed, or in this case, when a checkbox
        # is checked or unchecked, run the function
        self.table.itemChanged.connect(self.checkboxState)
        
        # add or subtract from the layer count
        self.table.itemChanged.connect(self.updateCountText)
        
    def updateCountText(self):
        """Activated when checkbox states change. Updates the count accordingly"""
        res_text = "Resolution set to " + self.resolution + " m"
        if len(self.datasets_to_download) == 1:
            self.layer_count_text.setText(str(len(self.datasets_to_download))+
                                          ' layer selected | ' + res_text)
        else:
            self.layer_count_text.setText(str(len(self.datasets_to_download))+
                                          ' layers selected | ' + res_text)
            
    def updateDataText(self, msg):
        self.data_info_text.setText(msg)
        
    def updateBaseUrl(self):
        self.url_base = self.url_base_field.text()
        
            
    def checkboxState(self, cbox):
        """itemChanged signal passes the checkbox (cbox). This function
           checks whether cbox was checked or unchecked and acts accordingly"""
        state = cbox.checkState()
        
        # 0 = unchecked, 2 = checked
        if state == 0:
            self.stateNegative(cbox)
        elif state == 2:
            self.statePositive(cbox)

    def stateNegative(self, cbox):
        """This function is called in case the cbox is unchecked.
           Removes the dataset in question from the list"""
           
        # cbox has a function to access its row number in the table
        # this is used to access label and year items,
        # since they're on the same row and their column number are known
        box_row = cbox.row()
        label_item = self.table.item(box_row, 0)
        label_text = label_item.text()
        
        year_item = self.table.item(box_row, 1)
        year_text = year_item.text()
        
        # create key in the same format as before
        dataset_key = label_text + ";" + year_text
        
        # if key already exists, remove it
        if dataset_key in self.datasets_to_download:
            self.datasets_to_download.remove(dataset_key)
    
    def statePositive(self, cbox):
        """This function is called in case the cbox is checked.
           Adds the dataset in question from the list. See above for details"""
        box_row = cbox.row()
        label_item = self.table.item(box_row, 0)
        label_text = label_item.text()

        year_item = self.table.item(box_row, 1)
        year_text = year_item.text()

        dataset_key = label_text + ";" + year_text
        self.datasets_to_download.append(dataset_key)

    def deleteDownloads(self):
        """Called when datasets are fetched more than once, which empties the list.
           Also updates layer count text"""
        self.datasets_to_download.clear()
        self.updateCountText()
    
    def estimateFileSize(self):
        """Is activated when user selects a resolution. Estimates the file size
        of a single layer download in MB based on known factors. These are:
        -extent, how many x & y lines there are and therefore, how many pixels
        -radiometric resolution (aka bit depth or data type in QGIS): 8, 16, 32 bits
            As of now, the radiometric resolution is hardcoded to be 16.
        Warns users of too large files (set to 50 MB atm)"""
        if self.admin_radio_button.isChecked():
            return
        
        ext = self.getExtent()
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        
        # (x-axis / resolution) * (y-axis / resolution)
        pixelcount = (xmax-xmin)/int(self.resolution) * ((ymax-ymin)/ int(self.resolution))
        
        data_type = 16
        
        # times radiometric resolution
        size_in_bits = pixelcount * data_type
        
        # size in bits -> to bytes -> to kB -> to MB
        size_in_mb = size_in_bits/8/1024/1024
        
        if size_in_mb > 50:
            self.sendWarning("Layer size warning", "Download is estimated to be: "+
                             str(int(size_in_mb)) + " MB", 6)
        
        
    def getValues(self):
        """Extracts all values (name/year tuples). Returns them as a list"""
        values = []
        
        for dataset_key in self.datasets_to_download:
            # get value by passing the key from the download list
            value = self.datasets_all[dataset_key]
            values.append(value)
            
        return values
            
    def getData(self):
        """
        Downloads raster datasets from Geocubes servers as selected by the user
        This is done by forming an url comprised of layer names, years, extent
        and resolution. Either directly creates a QGis raster layer by 
        passing the url as data source (referred to as temp layer, though strictly
        speaking I don't believe it's saved to some temp folder. Not sure though).
        Another option is to save layers to disk and passing that as the source.
        [SAVE TO DISK TO BE IMPLEMENTED]
        """
        # nothing will be downloaded if nothing is selected. Notifies user. Else continue
        if(len(self.datasets_to_download) == 0):
            self.updateDataText("Please select one or more layers!")
        elif not self.resolution:
            self.updateDataText("Please select resolution!")
        elif self.admin_radio_button.isChecked() and len(self.areas_box.checkedItems()) == 0:
            self.updateDataText("Please select admin areas!")
        else:
            # get info that's passed to the Geocubes server
            dataset_parameters = self.getValues()
            
            # this is needed to form a while loop, which is needed for the busy dialog
            done = False
            
            # while datasets are downloaded, an indicator will be shown
            self.busy_dialog.show()
            
            # a simple count of succesful downloads
            successful_layers = 0
        
            while not done:
                # 1 to n loops to download all selected data
                for parameter in dataset_parameters:
                    # accessing values, which are stored as tuples
                    name = parameter[0]
                    year = parameter[1]
                    
                    # forming the url that's passed to server
                    # see http://86.50.168.160/geocubes/examples/ 
                    # for examples of forming this url
                    if self.bbox_radio_button.isChecked():
                        data_url = self.getbBoxUrl(name, year)
                    else:
                        data_url = self.getAdminUrl(name, year)
                    
                    # creating raster layer by passing the url and giving
                    # name and year as layer names
                    raster_layer = QgsRasterLayer(data_url, ''.join([name, '_', year]))
                    
                    # if data query fails, inform user. If not, add to Qgis
                    if not raster_layer.isValid():
                        self.sendWarning("Layer invalid", ''.join([name,'_',year])+
                                         " failed to download", 9)
                    else:
                        QgsProject.instance().addMapLayer(raster_layer)
                        successful_layers += 1
                
                # once all layers are downloaded, inform how many were succesful
                self.updateDataText(str(successful_layers) + "/" +
                                    str(len(dataset_parameters))+ " layer(s)" +
                                    " successfully downloaded")
                self.busy_dialog.close()
                done = True
                
    def getbBoxUrl(self, name, year):
        extent = self.getExtent()
        bbox_url = (self.url_base + "/clip/" + self.resolution +
                        "/"+ name +"/bbox:" + self.formatExtent(extent)
                        + "/" + year)
        return bbox_url
    
    def getAdminUrl(self, name, year):
        areas = self.areaBoxSelection()
        admin_url = (self.url_base + "/clip/" + self.resolution +"/"+ name +
                     "/"+self.admin_area.lower()+":" + self.formatAreas(areas)
                        + "/" + year)
        return admin_url
            
    def getAreas(self):
        """Fetches a vector data of administrative divisions from Geocubes WFS 
           server. Passes this on to another function."""

        # don't do anything, if the box is empty
        if not self.admin_area:
            return
        
        # create a string to fetch the correct data
        area_name = "ogiir:" + self.admin_area.lower() + "_2018_4500k"
        self.busy_dialog.show()
        url = ("http://86.50.168.160/geoserver/ows?service=wfs&version=2.0.0"+ 
        "&request=GetFeature&typename="+area_name+"&pagingEnabled=true")
        
        # pass url and other relevant data to create a layer
        vector_layer = QgsVectorLayer(url, "WFS-layer", "WFS")
        
        if not vector_layer.isValid():
            self.updateDataText("WFS query failed")
            self.busy_dialog.close()
        else:
            # if everything went well, run another function on the layer
            self.updateAreaBox(vector_layer)
            self.vlayer = vector_layer

            """
            m_window = MapWindow(vector_layer)
            print(m_window)
            print(type(m_window))
            m_window.show()
            """
    def openMapWindow(self):
        if not self.vlayer:
            self.sendWarning("Layer missing", "Select admin area first", 6)
        else:
            #QgsProject.instance().addMapLayer(self.vlayer)
            """
            self.map_canvas.setExtent(self.vlayer.extent())
            self.map_canvas.setLayers([self.vlayer])'
            self.map_canvas.show()
            """
            self.map_canvas.addLayer(self.vlayer)
            
    def updateAreaBox(self, vlayer):
        """Populates the selectable box with whatever administrative areas
            the user has picked."""
        self.areas_box.clear()
        name_list = []
        
        # loop through features or rows in the layer
        for feature in vlayer.getFeatures():
            name_fi = feature[2]
            id_code = feature[1]
            # create a string from Finnish name and id code
            key = name_fi + ", " + str(id_code)
            
            name_list.append(key)
        
        name_list.sort()
        # add all area strings to the box
        self.areas_box.addItems(name for name in name_list)
        self.busy_dialog.close()
        
    def areaBoxSelection(self):
        return self.areas_box.checkedItems()
        
    def collapseExtentBox(self):
        self.extent_box.setCollapsed(True)
        
    def uncollapseExtentBox(self):
        self.extent_box.setCollapsed(False)
    
    def updateExtent(self):
        """Updates extent boxes when the canvas extent changes"""
        self.extent_box.setCurrentExtent(self.canvas.extent(), self.proj_crs)
        self.extent_box.setOutputExtentFromCurrent()
        
            
    def getExtent(self):
        """Current extent shown in the extent groupbox
        Returns a rectangle object"""
        output_extent = self.extent_box.outputExtent()
        return output_extent
        """
        
        QgsMessageLog.logMessage(output_extent,
                                 'geocubes_plugin',
                                 Qgis.Info)
        """
        
    def formatExtent(self,rectangle):
        """The extent coordinates need to be in certain format for the url
            This function's input is a Qgis rectangle and output a bbox string"""
        formatted_extent = (str(rectangle.xMinimum())+','+str(rectangle.yMinimum())
                            +','+str(rectangle.xMaximum())+','+str(rectangle.yMaximum()))
        return formatted_extent
    
    def formatAreas(self, areas):
        """Return areas selected by user in a format suitable for the url. Id codes
            are used to identify features. Nationwide (valtakunta) is a special case, since
            it's handled differently to the other datasets serverside"""
            
        if self.admin_area == 'Valtakunta':
            return str(1)
        else:
            # empty string forms a basis for the formatting
            codes = ""
            # loop through 1 to n areas. For each, add id code to string
            for area in areas:
                area_split = area.split(", ")
                code = area_split[len(area_split)-1]
                if not codes:
                    codes = code
                else:
                    codes = codes + "," + code
            return codes
        
    def run(self):
        """Run method that performs all the real work"""

        # if the plugin is started for the first time,
        # create necessary variables and connect signals to slots
        # signal/slot connection must only be made once;
        # unless disconnected elsewhere
        if self.first_start is True:
            self.first_start = False
            # the ui
            self.dlg = GeocubesPluginDialog()
            
            # current base url (shared by all queries) of the Geocubes project. Modify if url changes
            self.url_base = "http://86.50.168.160/geocubes"
            self.url_base_field = self.dlg.urlBaseField
            self.url_base_field.textEdited.connect(self.updateBaseUrl)
            
            
            # table to house the datasets: also add policies to fit the data
            # better on the table
            self.table = self.dlg.tableWidget
            self.table.setSizeAdjustPolicy(
                    QAbstractScrollArea.AdjustToContents)
            
            # connect click of the fetch data layers button to functions
            self.dlg.getContents.clicked.connect(self.setToTable)
            self.dlg.getContents.clicked.connect(self.deleteDownloads)
            
            # QGIS canvas
            self.canvas = self.iface.mapCanvas()
            self.canvas.extentsChanged.connect(self.updateExtent)

            
            # initialising the extent box
            # all the data is in ETRS89 / TM35FIN (EPSG:3067), 
            # therefore that's the default crs
            self.extent_box = self.dlg.mExtentGroupBox
            self.proj_crs = QgsCoordinateReferenceSystem('EPSG:3067')
            self.extent_box.extentChanged.connect(self.extentResolution)

            
            # box housing a drop-down list of possible raster resolutions
            self.resolution_box = self.dlg.resolutionBox
            self.resolution_box.activated.connect(self.setResolution)
            
            # estimate download file size when resolution changes
            self.resolution_box.activated.connect(self.estimateFileSize)
            
            self.resolution_box.activated.connect(self.updateCountText)

            
            self.data_button = self.dlg.getDataButton
            self.data_button.clicked.connect(self.getData)
            
            self.map_select_button = self.dlg.mapSelectButton
            self.map_select_button.clicked.connect(self.openMapWindow)
            
            
            # text that tells the user the current count of selected layers
            self.layer_count_text = self.dlg.layerCountText
            
            # text that informs the user on things related to downloading
            # the data layers
            self.data_info_text = self.dlg.dataInfoText
            
            # radio buttons for user to decide whether to get the data as
            # temporary layers or save the rasters to disc
            self.save_temp_button = self.dlg.saveToTempButton
            
            # radio buttons to decide what to use when cropping the data
            self.bbox_radio_button = self.dlg.bboxRadioButton
            self.admin_radio_button = self.dlg.adminRadioButton
            
            # show or hide the extent box based on which one is selected
            self.bbox_radio_button.clicked.connect(self.uncollapseExtentBox)
            self.admin_radio_button.clicked.connect(self.collapseExtentBox)
            
            
            self.admin_areas_box = self.dlg.adminAreasBox
            self.areas_box = self.dlg.areasBox
            admin_area_labels = ['Valtakunta', 'Aluehallintovirastojako', 'Maakuntajako',
                       'Kuntajako']
            self.admin_areas_box.addItems(label for label in admin_area_labels)
            self.admin_areas_box.currentTextChanged.connect(self.setAdminArea)
            self.admin_areas_box.currentTextChanged.connect(self.getAreas)
            
            self.busy_dialog = QgsBusyIndicatorDialog("Fetching data...", self.dlg)
            
            # initiate message bar that warns user when something goes wrong
            self.msg_bar = QgsMessageBar(self.dlg.tabWidget)
            self.msg_bar.setMinimumSize(550, 80)
            self.msg_bar.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
            
            self.vlayer = False
        
        # list of possible resolutions. Update if this changes
        resolutions = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000]
        # empty the box when plugin is restarted
        self.resolution_box.clear()
        self.resolution_box.addItems(str(resolution) for resolution in resolutions)
        # set the box empty by default
        self.resolution_box.setCurrentIndex(-1)
        
        # this variable houses the currently selected resolution
        self.resolution = self.resolution_box.currentText()
        
        self.admin_areas_box.setCurrentIndex(-1)
        self.admin_area = self.admin_areas_box.currentText()
        
        # an empty dictionary to house all the fetched datasets
        self.datasets_all = {}
        
        # an empty list for only the datasets the user has selected
        self.datasets_to_download = []
        
        if self.canvas.mapSettings().destinationCrs() != self.proj_crs:
            self.canvas.setDestinationCrs(self.proj_crs)
                                    
            self.sendWarning("CRS changed", "CRS must be EPSG:3067."+ 
                             " Destination CRS changed to it.", 9)
        # canvas extent at the start
        og_extent = self.canvas.extent()
        
        # these three things must be set when initialising the extent box
        self.extent_box.setOriginalExtent(og_extent, self.canvas.mapSettings().destinationCrs())
        self.extent_box.setCurrentExtent(og_extent, self.proj_crs)
        self.extent_box.setOutputCrs(self.proj_crs)
        
        # push current extent to the box
        self.updateExtent()
        
        self.extentResolution()
        
        # set default texts
        self.updateCountText()
        self.data_info_text.setText('Get datasets here')
        
        self.bbox_radio_button.setChecked(True)
        
        self.save_temp_button.setChecked(True)
        
        # make sure the table is empty on restart
        self.table.clear()
        
        self.areas_box.clear()
        
        self.url_base_field.setText(self.url_base)
        
        # show the dialog
        self.dlg.show()
        self.uncollapseExtentBox()
        
        self.map_canvas = MapWindow()
        """
        self.map_canvas.setMinimumSize(550, 150)
        self.map_canvas.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        """

        # Run the dialog event loop
"""
        MITEN SAADA RASTERITASO TALLENNETTUA:
        >provider = rlayer.dataProvider()
        >(provider.dataType(1))
         >https://qgis.org/api/classQgis.html
        >https://qgis.org/api/classQgsRasterFileWriter.html#a660aecebe6791d543b8c568edf0084f0
        >writeRaster:
            >https://qgis.org/api/classQgsRasterFileWriter.html#a660aecebe6791d543b8c568edf0084f0
"""
class MapWindow(QMainWindow):
    def __init__(self):
        QMainWindow.__init__(self)

        self.canvas = QgsMapCanvas()
        self.canvas.setMinimumSize(350, 350)
        self.canvas.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
        self.canvas.setCanvasColor(Qt.gray)

        #self.canvas.setExtent(layer.extent())
        #self.canvas.setLayers([layer])
        
        self.label_settings = QgsPalLayerSettings()
        text_format = QgsTextFormat()
        
        text_format.setFont(QFont("Times", 12))
        text_format.setSize(8)
        
        buffer_settings = QgsTextBufferSettings()
        buffer_settings.setEnabled(True)
        buffer_settings.setSize(0.6)
        buffer_settings.setColor(Qt.white)
        
        text_format.setBuffer(buffer_settings)
        self.label_settings.setFormat(text_format)
        self.label_settings.fieldName = "namefin"
        self.label_settings.placement = 0
        self.label_settings.enabled = True

        self.setCentralWidget(self.canvas)

        self.actionZoomIn = QAction("Zoom in", self)
        self.actionZoomOut = QAction("Zoom out", self)
        self.actionPan = QAction("Pan", self)

        self.actionZoomIn.setCheckable(True)
        self.actionZoomOut.setCheckable(True)
        self.actionPan.setCheckable(True)

        self.actionZoomIn.triggered.connect(self.zoomIn)
        self.actionZoomOut.triggered.connect(self.zoomOut)
        self.actionPan.triggered.connect(self.pan)

        self.toolbar = self.addToolBar("Canvas actions")
        self.toolbar.addAction(self.actionZoomIn)
        self.toolbar.addAction(self.actionZoomOut)
        self.toolbar.addAction(self.actionPan)

        # create the map tools
        self.toolPan = QgsMapToolPan(self.canvas)
        self.toolPan.setAction(self.actionPan)
        self.toolZoomIn = QgsMapToolZoom(self.canvas, False) # false = in
        self.toolZoomIn.setAction(self.actionZoomIn)
        self.toolZoomOut = QgsMapToolZoom(self.canvas, True) # true = out
        self.toolZoomOut.setAction(self.actionZoomOut)

        self.pan()

    def zoomIn(self):
        self.canvas.setMapTool(self.toolZoomIn)

    def zoomOut(self):
        self.canvas.setMapTool(self.toolZoomOut)

    def pan(self):
        self.canvas.setMapTool(self.toolPan)
        
    def addLayer(self, layer):
        QgsProject.instance().addMapLayer(layer, False)
        layer.setLabelsEnabled(True)
        layer_labeling = QgsVectorLayerSimpleLabeling(self.label_settings)
        layer.setLabeling(layer_labeling)
        self.canvas.setExtent(layer.extent())
        self.canvas.setLayers([layer])
        self.show()
        """
        start = time.time()
        PERIOD_OF_TIME = 10
        while True:
            self.canvas.show()
            if time.time() > start + PERIOD_OF_TIME : 
                print("LOPETA")
                break
        """